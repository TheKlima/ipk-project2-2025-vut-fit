/**
 * @file udp-serv.cpp
 * @author Andrii Klymenko
 * @brief Implementation of the UDP version of pseudo-server of IPK25CHAT protocol for project's testing
 * Partially generated by AI
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <iostream>
#include <assert.h>
#include <cstring>

enum class Protocol_msg_type
{
    M_CONFIRM = 0x00,
    M_REPLY = 0x01,
    M_AUTH = 0x02,
    M_JOIN = 0x03,
    M_MSG = 0x04,
    M_PING = 0xFD,
    M_ERR = 0xFE,
    M_BYE = 0xFF,
    M_UNKNOWN
};

constexpr unsigned UDP_MAX_MSG_SIZE{60007};
constexpr unsigned MAX_BUFFER_SIZE{UDP_MAX_MSG_SIZE + 1};
constexpr uint16_t PORT{8080};

Protocol_msg_type getMsgType(const char* msg)
{
    assert(msg);

    switch (static_cast<unsigned char>(msg[0])) // treat msg[0] as byte
    {
        case static_cast<unsigned char>(Protocol_msg_type::M_BYE):
            return Protocol_msg_type::M_BYE;
        case static_cast<unsigned char>(Protocol_msg_type::M_ERR):
            return Protocol_msg_type::M_ERR;
        case static_cast<unsigned char>(Protocol_msg_type::M_CONFIRM):
            return Protocol_msg_type::M_CONFIRM;
        case static_cast<unsigned char>(Protocol_msg_type::M_REPLY):
            return Protocol_msg_type::M_REPLY;
        case static_cast<unsigned char>(Protocol_msg_type::M_AUTH):
            return Protocol_msg_type::M_AUTH;
        case static_cast<unsigned char>(Protocol_msg_type::M_JOIN):
            return Protocol_msg_type::M_JOIN;
        case static_cast<unsigned char>(Protocol_msg_type::M_MSG):
            return Protocol_msg_type::M_MSG;
        case static_cast<unsigned char>(Protocol_msg_type::M_PING):
            return Protocol_msg_type::M_PING;
        default:
            return Protocol_msg_type::M_UNKNOWN;
    }
}

uint16_t getMessageId(const char* msg)
{
    assert(msg); // assuming msg[0] is the type, msg[1-2] are msg_id
    uint16_t net_id;
    std::memcpy(&net_id, msg + 1, sizeof(net_id));
    return ntohs(net_id);
}

void addMsgIdToMsgToServer(uint16_t msg_id, std::string& msg_to_server)
{
    uint16_t net_id = htons(msg_id);
    msg_to_server.append(reinterpret_cast<const char*>(&net_id), sizeof(net_id));
}

void buildConfirmMsg(std::string& msg_from_server, uint16_t ref_msg_id)
{
    msg_from_server = std::string{static_cast<char> (Protocol_msg_type::M_CONFIRM)};
    addMsgIdToMsgToServer(ref_msg_id, msg_from_server);
}

void buildPingMsg(std::string& msg_from_server, uint16_t ref_msg_id)
{
    msg_from_server = std::string{static_cast<char> (Protocol_msg_type::M_PING)};
    addMsgIdToMsgToServer(ref_msg_id, msg_from_server);
}

void buildTooLongMsg(std::string& msg_from_server)
{
    msg_from_server = std::string{};

    for(int i = 0; i <= UDP_MAX_MSG_SIZE; ++i)
    {
        msg_from_server.push_back('a');
    }
}

void sendMsgToServer(int sockfd, struct sockaddr_in* cliaddr, socklen_t len, const std::string& msg_from_server)
{
    int res = sendto(sockfd, msg_from_server.data(), msg_from_server.size(), 0, (struct sockaddr*)cliaddr, len);
    if(res == -1)
    {
        std::cerr << "Error! Couldn't send a message to the server: send() has failed." << std::endl;
        abort();
    }
}

const char* printVariableLengthData(const char* data)
{
    while(*data)
    {
        std::cout << *data;
        ++data;
    }

    return data;
}

void printMsg(const char* msg, bool is_client_msg)
{
    if(is_client_msg)
    {
        printf("C: ");
    }
    else
    {
        printf("S: ");
    }

    const char* variable_length_data_ptr{nullptr};

    switch(getMsgType(msg))
    {
        case Protocol_msg_type::M_CONFIRM:
            std::cout << "CONFIRM: " << getMessageId(msg) << std::endl;
            break;
        case Protocol_msg_type::M_REPLY:
            std::cout << "REPLY: " << getMessageId(msg) << (msg[3] ? " OK " : " NOK ") << getMessageId(msg + 3) << " IS " << msg + 6 << std::endl;
            break;
        case Protocol_msg_type::M_AUTH:
            std::cout << "AUTH: " << getMessageId(msg) << ' ';
            variable_length_data_ptr = printVariableLengthData(msg + 3);
            std::cout << " AS ";
            variable_length_data_ptr = printVariableLengthData(variable_length_data_ptr + 1);
            std::cout << " USING ";
            variable_length_data_ptr = printVariableLengthData(variable_length_data_ptr + 1);
            std::cout << std::endl;
            assert(*variable_length_data_ptr == '\0');
            break;
        case Protocol_msg_type::M_ERR:
            std::cout << "ERR: " << getMessageId(msg) << " FROM ";
            variable_length_data_ptr = printVariableLengthData(msg + 3);
            std::cout << " IS ";
            variable_length_data_ptr = printVariableLengthData(variable_length_data_ptr + 1);
            std::cout << std::endl;
            assert(*variable_length_data_ptr == '\0');
            break;
        case Protocol_msg_type::M_BYE:
            std::cout << "BYE: " << getMessageId(msg) << " FROM ";
            variable_length_data_ptr = printVariableLengthData(msg + 3);
            std::cout << std::endl;
            assert(*variable_length_data_ptr == '\0');
            break;
        case Protocol_msg_type::M_PING:
            std::cout << "PING: " << getMessageId(msg) << std::endl;
            break;
        case Protocol_msg_type::M_MSG:
            std::cout << "MSG: " << getMessageId(msg) << " FROM ";
            variable_length_data_ptr = printVariableLengthData(msg + 3);
            std::cout << " IS ";
            variable_length_data_ptr = printVariableLengthData(variable_length_data_ptr + 1);
            std::cout << std::endl;
            assert(*variable_length_data_ptr == '\0');
            break;
        case Protocol_msg_type::M_JOIN:
            std::cout << "JOIN: " << getMessageId(msg) << " to ";
            variable_length_data_ptr = printVariableLengthData(msg + 3);
            std::cout << " AS ";
            variable_length_data_ptr = printVariableLengthData(variable_length_data_ptr + 1);
            std::cout << std::endl;
            assert(*variable_length_data_ptr == '\0');
            break;
    }
}

uint16_t getMsgId()
{
    uint16_t result = 0;
    int tmp;
    while(isdigit(tmp = getchar()))
    {
        result = result * 10 + tmp - '0';
    }
    ungetc(tmp, stdin);
    return result;
}

void buildByeMsg(std::string& msg_from_server, uint16_t msg_id)
{
    msg_from_server = std::string{static_cast<char> (Protocol_msg_type::M_BYE)};
    addMsgIdToMsgToServer(msg_id, msg_from_server);
    // msg_from_server.append("aaaaaaaaaaaaaaaaaaaaa");
    // msg_from_server.push_back('\0');
    msg_from_server.append("server_display_name\0", strlen("server_display_name\0") + 1);
}

void buildReplyMsg(std::string& msg_from_server, uint16_t msg_id)
{
    msg_from_server = std::string{static_cast<char> (Protocol_msg_type::M_REPLY)};
    addMsgIdToMsgToServer(msg_id, msg_from_server);
    assert(getchar() == ' ');
    msg_from_server.push_back(getchar() == '0' ? 0 : 1);
    assert(getchar() == ' ');
    addMsgIdToMsgToServer(getMsgId(), msg_from_server);
    msg_from_server.append("reply msg content.\0", strlen("reply msg content.") + 1);
}

void buildErrMsg(std::string& msg_from_server, uint16_t msg_id)
{
    msg_from_server = std::string{static_cast<char> (Protocol_msg_type::M_ERR)};
    addMsgIdToMsgToServer(msg_id, msg_from_server);
    // msg_from_server.append("aaaaaaaaaaaaaaaaaaaa");
    // msg_from_server.push_back('\0');
    // msg_from_server.push_back('a');
    // msg_from_server.push_back('\0');
    msg_from_server.append("server_display_name\0server err msg content.\0", strlen("server display name") + strlen("server err msg content.") + 2);
}

void buildMsgMsg(std::string& msg_from_server, uint16_t msg_id)
{
    msg_from_server = std::string{static_cast<char> (Protocol_msg_type::M_MSG)};
    addMsgIdToMsgToServer(msg_id, msg_from_server);
    // msg_from_server.append("aaaaaaaaaaaaaaaaaaaa");
    // msg_from_server.push_back('\0');
    // msg_from_server.push_back('a');
    // msg_from_server.push_back('\0');
    msg_from_server.append("server_display_name\0server msg msg content.\0", strlen("server display name") + strlen("server msg msg content.") + 2);
}

// Function to handle communication with the client
void func(int sockfd) {
    char msg_to_server[MAX_BUFFER_SIZE]{0, };
    std::string msg_from_server{};
    struct sockaddr_in cliaddr;
    socklen_t len = sizeof(cliaddr);

    bool is_send{};

    // Infinite loop for communication
    for (;;) {
        if(getchar() != 's')
        {
            // Receive message from client
            std::cout << "Waiting for client's message..." << std::endl;
            int n = recvfrom(sockfd, msg_to_server, MAX_BUFFER_SIZE, 0, (struct sockaddr*)&cliaddr, &len);
            if (n < 0) {
                perror("recvfrom failed");
                break;
            }

            printMsg(msg_to_server, true);
            bzero(msg_to_server, MAX_BUFFER_SIZE);
        }
        else
        {
            // processing stdin
            switch(getchar())
            {
                case 'c':
                    buildConfirmMsg(msg_from_server, getMsgId());
                    break;
                case 'b':
                    buildByeMsg(msg_from_server, getMsgId());
                    break;
                case 'r':
                    buildReplyMsg(msg_from_server, getMsgId());
                    break;
                case 'e':
                    buildErrMsg(msg_from_server, getMsgId());
                    break;
                case 't':
                    buildTooLongMsg(msg_from_server);
                    break;
                case 'm':
                    buildMsgMsg(msg_from_server, getMsgId());
                    break;
                case 'p':
                    buildPingMsg(msg_from_server, getMsgId());
                    break;
            }

            printMsg(msg_from_server.c_str(), false);
            sendMsgToServer(sockfd, &cliaddr, len, msg_from_server);
        }

    }
}

// Driver function
int main() {
    int sockfd;
    struct sockaddr_in servaddr;

    // Create UDP socket
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd == -1) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    } else {
        printf("Socket successfully created..\n");
    }

    // Set server address and port
    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // Listen on all interfaces
    servaddr.sin_port = htons(PORT);

    // Bind the socket to the server address
    if (bind(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) != 0) {
        perror("socket bind failed");
        close(sockfd);
        exit(EXIT_FAILURE);
    } else {
        printf("Socket successfully binded..\n");
    }

    // Call the function to handle communication
    func(sockfd);

    // Close the socket
    close(sockfd);
}