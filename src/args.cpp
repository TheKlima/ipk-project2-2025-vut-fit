/**
 * @file args.cpp
 * @author Andrii Klymenko
 * @brief Implements Args class.
 */

#include "args.h"

#include <complex>

#include "error.h"
#include "exception.h"
#include <iostream>
#include <arpa/inet.h> // inet_pton()
#include <netdb.h>     // getaddrinfo(), struct addrinfo
#include <cstring>     // std::memcpy()

Args::Args(const int argc, char** argv)
    :
    m_server_port{4567},
    m_udp_confirm_timeout{250},
    m_udp_max_retrans_count{3},
    m_is_help_used{false},
    m_arg_flags{'t', 's', 'p', 'd', 'r', 'h'}
{
    const char* server_addr{nullptr};

    for(int i{1}; i < argc; i += 2)
    {
        if(strlen(argv[i]) == 2 && argv[i][0] == '-')
        {
            if(argv[i][1] == m_arg_flags[0]) // '-t '
            {
              	if(strcmp(argv[i + 1], "tcp") == 0)
                {
                    m_is_tcp = true;
                }
                else if(strcmp(argv[i + 1], "udp") == 0)
                {
                    m_is_tcp = false;
                }
                else
                {
                    throw Exception{"invalid value for -t flag: expected tcp or udp."};
                }
            }
            else if(argv[i][1] == m_arg_flags[1]) // '-s'
            {
                server_addr = argv[i + 1];
            }
            else if(argv[i][1] == m_arg_flags[2]) // '-p'
            {
                m_server_port = std::stoi(argv[i + 1], nullptr, 10);
            }
            else if(argv[i][1] == m_arg_flags[3]) // '-d'
            {
                m_udp_confirm_timeout = std::stoi(argv[i + 1], nullptr, 10);
            }
            else if(argv[i][1] == m_arg_flags[4]) // '-r'
            {
                m_udp_max_retrans_count = std::stoi(argv[i + 1], nullptr, 10);
            }
            else if(argv[i][1] == m_arg_flags[5]) // '-h'
            {
                m_is_help_used = true;
                return;
            }
        }
    }

    processServerAddress(server_addr);
}

void Args::printHelp()
{
    std::cout << "Usage: ./ipk25-chat {-t transport_protocol} {-s serverIP/hostname} [-p server_port] [-d udp_timeout]"
                 " [-r max_udp_retrans] [-h]\n";
}

// this function was generated by AI
void Args::hostnameToIpAddress(const char* hostname)
{
    struct addrinfo hints{};
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;  // Use TCP by default

    struct addrinfo* result{nullptr};

    char portStr[6]{}; // Max 5 digits + null terminator
    snprintf(portStr, sizeof(portStr), "%d", m_server_port);

    if(getaddrinfo(hostname, portStr, &hints, &result) != 0)
    {
        throw Exception{"couldn't convert a hostname to IP address."};
    }

    std::memcpy(&m_server_addr, result->ai_addr, result->ai_addrlen);
    freeaddrinfo(result);
}

// this function was generated by AI
void Args::processServerAddress(const char* server_addr)
{
    const int result{inet_pton(AF_INET, server_addr, &m_server_addr.sin_addr)};

    if(result == 0)
    {
        hostnameToIpAddress(server_addr);  // Convert hostname to IP
    }
    else if (result == -1)
    {
        throw Exception{"couldn't convert a network address."};
    }

    // Always set port AFTER assigning the address
    m_server_addr.sin_port = htons(m_server_port);
    m_server_addr.sin_family = AF_INET;
}

// 'getters'

bool Args::getIsTcp() const
{
    return m_is_tcp;
}

uint8_t Args::getUdpMaxRetransCount() const
{
    return m_udp_max_retrans_count;
}

struct sockaddr_in* Args::getServerAddrStructAddress()
{
    return &m_server_addr;
}

int Args::getSizeofServerAddrStruct() const
{
    return sizeof(m_server_addr);
}

uint16_t Args::getUdpConfirmTimeout() const
{
    return m_udp_confirm_timeout;
}

bool Args::getIsHelpUsed() const
{
    return m_is_help_used;
}

// end of 'getters'
