/**
 * @file client.cpp
 * @author Andrii Klymenko
 * @brief Implementation of the base class for the TCP and UDP versions of IPK25-CHAT client.
 */

#include "client.h"
#include "udp-client.h"
#include "tcp-client.h"
#include "error.h"
#include <exception.h>
#include <sys/socket.h> // socket()
#include <iostream>

Client::Client(const Args& args)
    :
    m_args{args},
    m_current_state{FSM_state::S_START},
    m_user_display_name{"unknown"},
    m_is_waiting_for_reply{false},
    m_server_msg{std::make_unique<char[]>(m_args.getIsTcp() ? Tcp_client::s_MAX_MSG_SIZE + 1 : Udp_client::s_MAX_MSG_SIZE + 1)}
{
    m_sigint_callback = [this]() { sigintHandler(); };
    std::signal(SIGINT, [](int) { m_sigint_callback(); });
    createClientSocket();
    createEpollFd();
    createTimerFd();

    addFileDescriptorToEpollEvent(m_stdin_event, STDIN_FILENO);
    addFileDescriptorToEpollEvent(m_socket_event, m_client_socket);
    addFileDescriptorToEpollEvent(m_timer_event, m_timer_fd);
    addEntriesToEpollInstance();
}

bool Client::isValidDisplayNameLength(unsigned display_name_length) const
{
    return display_name_length >= 1 && display_name_length << s_DISPLAY_NAME_MAX_LENGTH;
}

bool Client::isValidMsgContentLength(unsigned msg_content_length) const
{
    return msg_content_length >= 1 && msg_content_length <= s_MSG_CONTENT_MAX_LENGTH;
}

Protocol_msg_type Client::getUserMsgType(std::string_view command) const
{
    if(command == m_user_commands[0])
    {
        return Protocol_msg_type::M_AUTH;
    }

    if(command == m_user_commands[2])
    {
        return Protocol_msg_type::M_JOIN;
    }

    return Protocol_msg_type::M_MSG;
}

void Client::outputIncomingMsg(std::string display_name, std::string content) const
{
    std::cout << display_name << ": " << content << std::endl;
}

void Client::outputIncomingReply(bool is_positive, std::string content) const
{
    std::cout << "Action " << (is_positive ? "Success" : "Failure") << ": " << content << std::endl;
}

// this function was generated by AI
void Client::startTimer(uint16_t time)
{
    struct itimerspec timer_spec{};
    timer_spec.it_value.tv_sec = time / 1000; // Convert ms to seconds
    timer_spec.it_value.tv_nsec = (time % 1000) * 1000000; // Convert remainder to nanoseconds
    timer_spec.it_interval.tv_sec = 0; // One-shot timer
    timer_spec.it_interval.tv_nsec = 0;

    if(timerfd_settime(m_timer_fd, 0, &timer_spec, nullptr) == -1)
    {
        throw Exception{"failed to start confirmation timer."};
    }
}

// this function was generated by AI
void Client::stopTimer()
{
    struct itimerspec timer_spec{};
    timer_spec.it_value.tv_sec = 0; // Disarm the timer
    timer_spec.it_value.tv_nsec = 0;
    timer_spec.it_interval.tv_sec = 0;
    timer_spec.it_interval.tv_nsec = 0;

    if(timerfd_settime(m_timer_fd, 0, &timer_spec, nullptr) == -1)
    {
        throw Exception{"failed to stop confirmation timer."};
    }
}

void Client::createTimerFd()
{
    m_timer_fd = timerfd_create(CLOCK_MONOTONIC, 0);

    if(m_timer_fd == -1)
    {
        throw Exception{"couldn't create timer file descriptor: timerfd_create() has failed."};
    }
}

std::unique_ptr<Client> Client::create(const Args& args)
{
    if(args.getIsTcp())
    {
        return std::unique_ptr<Client>(new Tcp_client{args});
    }

    return std::unique_ptr<Client>(new Udp_client{args});
}

void Client::createClientSocket()
{
    if(m_args.getIsTcp())
    {
        m_client_socket = socket(AF_INET, SOCK_STREAM, 0);
    }
    else
    {
        m_client_socket = socket(AF_INET, SOCK_DGRAM, 0);
    }

    if(m_client_socket < 0)
    {
        throw Exception{"couldn't create a client socket: socket() has failed."};
    }
}

bool Client::processNonMsgToServer(const std::vector<std::string>& user_input)
{
    if(user_input[0] == m_user_commands[3])
    {
        m_user_display_name = user_input[1];
        return true;
    }

    if(user_input[0] == m_user_commands[1])
    {
        printSupportedCommands();
        return true;
    }

    return false;
}

void Client::buildUserMsgToServer(const std::vector<std::string>& user_input)
{
    switch(getUserMsgType(user_input[0]))
    {
        case Protocol_msg_type::M_AUTH:
            buildAuthMsg(user_input[1], user_input[2]);
            break;
        case Protocol_msg_type::M_JOIN:
            buildJoinMsg(user_input[1]);
            break;
        case Protocol_msg_type::M_MSG:
            buildMsgMsg(user_input[0]);
            break;
        default:
            throw Exception{"function buildUserMsgToServer() is expected to be called when user enters an auth command"
                            " or join command or a message."};
    }
}

void Client::printSupportedCommands() const
{
    std::cout << "Supported commands:\n/auth {Username} {Secret} {DisplayName} - client authentication (signing in)"
                 " using user-provided username, display name and a password\n/join {ChannelID} - client's request to"
                 " join a chat channel by its identifier\n/rename {DisplayName} - locally changes the display name of"
                 " the user to be sent with new messages/selected commands\n/help - prints out supported local commands"
                 " with their parameters and a description" << std::endl;
}

void Client::addFileDescriptorToEpollEvent(struct epoll_event& event, const int file_descriptor)
{
    event.data.fd = file_descriptor;
}

// this function was generated by AI
void Client::disableStdinEvents()
{
    m_stdin_event.events = EPOLLERR | EPOLLHUP;  // Disable EPOLLIN
    if(epoll_ctl(m_epoll_fd, EPOLL_CTL_MOD, STDIN_FILENO, &m_stdin_event) != 0)
    {
        throw Exception{"couldn't add an entry to epoll instance: epoll_ctl() has failed."};
    }
}

// this function was generated by AI
void Client::enableStdinEvents()
{
    m_stdin_event.events = EPOLLIN | EPOLLERR | EPOLLHUP;  // Enable EPOLLIN again
    if(epoll_ctl(m_epoll_fd, EPOLL_CTL_MOD, STDIN_FILENO, &m_stdin_event) != 0)
    {
        throw Exception{"couldn't add an entry to epoll instance: epoll_ctl() has failed."};
    }
}

void Client::addEntriesToEpollInstance()
{
    if(epoll_ctl(m_epoll_fd, EPOLL_CTL_ADD, m_client_socket, &m_socket_event) != 0 ||
       epoll_ctl(m_epoll_fd, EPOLL_CTL_ADD, STDIN_FILENO, &m_stdin_event) != 0 ||
       epoll_ctl(m_epoll_fd, EPOLL_CTL_ADD, m_timer_fd, &m_timer_event) != 0)
    {
        throw Exception{"couldn't add an entry to epoll instance: epoll_ctl() has failed."};
    }
}

void Client::createEpollFd()
{
    if((m_epoll_fd = epoll_create1(0)) < 0)
    {
        throw Exception{"couldn't create an epoll file descriptor: epoll_crate1() has failed."};
    }
}

// Define static function variable
std::function<void()> Client::m_sigint_callback = nullptr;

Client::~Client()
{
    close(m_client_socket);
    close(m_epoll_fd);
}

bool Client::run()
{
    while(true)
    {
        // Wait for events
        m_epoll_event_count = epoll_wait(m_epoll_fd, &m_actual_event, s_MAX_EPOLL_EVENT_NUMBER, -1);

        if(m_epoll_event_count == -1)
        {
            if(errno == EINTR) // epoll_wait was interrupted by a signal
            {
                continue;
            }

            throw Exception{"epoll_wait() has failed."};
        }

        if(m_epoll_event_count == 1)
        {
            if(m_actual_event.data.fd == STDIN_FILENO)
            {
                processStdinEvent();
            }
            else if(m_actual_event.data.fd == m_client_socket)
            {
                uint8_t result = processSocketEvent();

                if(result == 0 || result == 1)
                {
                    return static_cast<bool> (result);
                }
            }
            else
            {
                processTimerEvent();
            }
        }
    }

    return false;
}

std::vector<std::string> Client::parseUserInput()
{
    std::string user_input{};

    if(!std::getline(std::cin, user_input))
    {
        if(std::cin.eof())
        {
            sendByeMsgToServer();
            if(m_args.getIsTcp())
            {
                throw Exception{""};
            }

            return {};
        }
    }

    std::smatch user_input_matches{};

    if(std::regex_match(user_input, user_input_matches, getAuthCommandRegex()))
    {
        if(!canSendMessageType(Protocol_msg_type::M_AUTH))
        {
            printErrMsg("you can't send this type of message in the current client state.");
            return {};
        }

        if(user_input_matches[2].length() > s_USERNAME_MAX_LENGTH || user_input_matches[3].length() > s_USER_SECRET_MAX_LENGTH
           || !isValidDisplayNameLength(user_input_matches[4].length()))
        {
            printErrMsg("invalid length of the message parameter.");
            return {};
        }
    }
    else if(std::regex_match(user_input, user_input_matches, getJoinCommandRegex()))
    {
        if(!canSendMessageType(Protocol_msg_type::M_JOIN))
        {
            printErrMsg("you can't send this type of message in the current client state.");
            return {};
        }

        if(user_input_matches[2].length() > s_CHANEL_ID_MAX_LENGTH)
        {
            printErrMsg("invalid length of the message parameter.");
            return {};
        }
    }
    else if(std::regex_match(user_input, user_input_matches, getRenameCommandRegex()))
    {
        if(m_current_state == FSM_state::S_JOIN) // assertion
        {
            printErrMsg("you can't rename yourself in the current application state.");
            return {};
        }

        if(!isValidDisplayNameLength(user_input_matches[2].length()))
        {
            printErrMsg("invalid length of the message parameter.");
            return {};
        }
    }
    else if(std::regex_match(user_input, user_input_matches, getHelpCommandRegex()))
    {
        return {user_input};
    }
    else if(!user_input.empty() && user_input[0] != '/'
            && std::regex_match(user_input, user_input_matches, getUserMsgRegex()))
    {
        if(!canSendMessageType(Protocol_msg_type::M_MSG))
        {
            printErrMsg("you can't send this type of message in the current client state.");
            return {};
        }

        if(!isValidMsgContentLength(user_input_matches[1].length()))
        {
            printErrMsg("invalid length of the message parameter.");
            return {};
        }
    }
    else
    {
        printErrMsg("invalid user input.");
        return {};
    }

    return getUserInput(user_input_matches);
}

bool Client::canSendMessageType(Protocol_msg_type msg_type) const
{
    if(msg_type == Protocol_msg_type::M_AUTH)
    {
        return m_current_state == FSM_state::S_START || m_current_state == FSM_state::S_AUTH;
    }

    return m_current_state == FSM_state::S_OPEN;
}

void Client::printErrFromServer(std::string display_name, std::string message_content) const
{
    std::cout << "ERROR FROM " << display_name << ": " << message_content << std::endl;
}

std::vector<std::string> Client::getUserInput(const std::smatch& user_input_matches) const
{
    std::vector<std::string> user_input{};

    for(int i{0}; i < static_cast<int> (user_input_matches.size()) - 1; ++i)
    {
        user_input.push_back(user_input_matches[i + 1]);
    }

    return user_input;
}

const std::string& Client::getAlphaNumericUnderlineDash()
{
    static const std::string value{"([a-zA-Z0-9_-]+)"};
    return value;
}

const std::string& Client::getPrintableChars()
{
    static const std::string value{"([!-~]+)"};
    return value;
}

const std::string& Client::getPrintableCharsSpaceLf()
{
    static const std::string value{"([\x20-\x7E\n]+)"};
    return value;
}

const std::regex& Client::getAuthCommandRegex()
{
    static const std::regex value{"(/auth) " + getAlphaNumericUnderlineDash() + " " + getAlphaNumericUnderlineDash() + " " + getPrintableChars()};
    return value;
}

const std::regex& Client::getJoinCommandRegex()
{
    static const std::regex value{"(/join) " + getAlphaNumericUnderlineDash()};
    return value;
}

const std::regex& Client::getRenameCommandRegex()
{
    static const std::regex value{"(/rename) " + getPrintableChars()};
    return value;
}

const std::regex& Client::getHelpCommandRegex()
{
    static const std::regex value{"(/help)"};
    return value;
}

const std::regex& Client::getUserMsgRegex()
{
    static const std::regex value{getPrintableCharsSpaceLf()};
    return value;
}
